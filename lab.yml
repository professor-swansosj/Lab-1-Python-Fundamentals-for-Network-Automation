title: "Lab 1 — Python Fundamentals & Structured Data"
course: "Software Defined Networking"
module: "Network Automation Fundamentals"
lab_number: 1
time_estimate: "60–90 min"

repo_tree:
  enabled: true
  root: "."                # repo root
  max_depth: 3             # keep trees short; change as you like
  ignore:                  # glob patterns to skip (important for stability)
    - "_template"
    - "_render"
    - "__pycache__"
    - "node_modules"
    - "venv"
    - ".venv"
    - "*.pyc"


objectives:
  - "Build and use Python functions, classes, and methods."
  - "Implement basic exception handling with try/except."
  - "Work with structured data files: JSON, YAML, XML, and CSV."
  - "Log meaningful events to a file for grading and troubleshooting."
  - "Organize code into modules and run via the main guard."

python_version: "3.11"
accounts: ["GitHub"]
devices: ["Local filesystem + sample structured data"]

deliverables:
  readme_summary: "Standardized README describing objectives, prerequisites, grading, and tips."
  instructions_summary: "Step-by-step INSTRUCTIONS with required log markers; artifacts created under data/ and logs/."

grading:
  total_points: 75
  rows:
    - { step: "Step 2", requirement: "Dev Container opened; dependencies available", points: 5 }
    - { step: "Step 4", requirement: "JSON parsed successfully (`PARSE_JSON_SUCCESS`)", points: 5 }
    - { step: "Step 4", requirement: "YAML parsed successfully (`PARSE_YAML_SUCCESS`)", points: 5 }
    - { step: "Step 4", requirement: "XML parsed successfully (`PARSE_XML_SUCCESS`)", points: 5 }
    - { step: "Step 4", requirement: "CSV parsed successfully (`PARSE_CSV_SUCCESS`)", points: 5 }
    - { step: "Step 5", requirement: "At least one device summarized (`DEVICE_SUMMARY`)", points: 5 }
    - { step: "Step 6", requirement: "Interface message logged (`INTERFACE_MSG`)", points: 5 }
    - { step: "Step 6", requirement: "Device message logged (`DEVICE_MSG`)", points: 5 }
    - { step: "Step 6", requirement: "VLAN message logged (`VLAN_MSG`)", points: 5 }
    - { step: "Step 7", requirement: "Clean module structure (class + parser functions imported and used)", points: 10 }
    - { step: "Step 8", requirement: "Commit, push, and PR opened; logs present with start/end markers", points: 15 }

tips:
  - title: "Dev container / dependencies"
    symptom: "ImportError for yaml, csv, or XML libraries"
    fix: "Reopen in dev container; verify with `pip list`. If needed, run `pip install -r requirements.txt`."
  - title: "Wrong data paths"
    symptom: "FileNotFoundError when parsing `data/*`"
    fix: "Run from repo root and use relative paths like `data/devices.json`."
  - title: "Empty or invalid JSON/YAML/XML"
    symptom: "Parse errors or zero-length data"
    fix: "Use the provided sample files; validate formatting before parsing."
  - title: "No logs written"
    symptom: "`logs/lab.log` missing or empty"
    fix: "Call `logging.basicConfig(filename='logs/lab.log', level=logging.INFO)` once, near program start."

autograder:
  log_path: "logs/lab.log"
  required_markers:
    - "LAB1_START"
    - "[STEP 2] Dev Container Started"
    - "PARSE_JSON_SUCCESS"
    - "PARSE_YAML_SUCCESS"
    - "PARSE_XML_SUCCESS"
    - "PARSE_CSV_SUCCESS"
    - "DEVICE_SUMMARY"
    - "INTERFACE_MSG"
    - "DEVICE_MSG"
    - "VLAN_MSG"
    - "LAB1_END"

license: "© 2025 Sheldon Swanson — Classroom use."

readme_topic:
  - title: "Python Functions"
    content: >
      Building off the Basics in Python from your Scripting course one of the most useful features 
      of Python is the ability to write your own functions(). A `Python Function` is simply a block 
      of code that you can reuse. Rather than write giant single execution programs we break the code 
      up into smaller blocks that we call functions(). A function can take different inputs known as 
      arguments such as variables, lists, dictionaires, and tuples as an input that will be passed to 
      the function upon execution. Functions do not require arguments to be passed in but it is common 
      to see. For example a simply function that prints a message does not need anything else to execute 
      successfully where a custom message that would require say a device hostname as part of the message 
      will need that hostname passed in upon runtime.
  - title: "Python Classes/Objects"
    content: >
      Another powerful feature of Python is the ability to create your own `Classes` and `Objects`. 
      A class is a blueprint for an object. An object is an instance of a class. Classes can contain 
      attributes (variables) and methods (functions). Classes are used to model real-world entities 
      and their behaviors. For example, you might have a class called `NetworkDevice` that has attributes 
      like `hostname`, `ip_address`, and `device_type`, and methods like `connect()`, `disconnect()`, 
      and `get_status()`. You can then create multiple instances of the `NetworkDevice` class, each 
      representing a different network device.
  - title: "Exceptions and Error Handling"
    content: >
      When writing code, it is common to encounter errors. Python provides a way to handle these errors 
      gracefully using `try` and `except` blocks. The code that might raise an exception is placed inside 
      the `try` block, and the code that handles the exception is placed inside the `except` block. This 
      allows you to catch and handle specific exceptions, preventing your program from crashing. For example, 
      when working with files, you might want to catch a `FileNotFoundError` if the file you are trying to 
      open does not exist.
  - title: "JSON"
    content: >
      `JSON` (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans 
      to read and write, and easy for machines to parse and generate. It is commonly used for transmitting 
      data between a server and a web application, as well as for configuration files. In Python, you can 
      work with JSON data using the built-in `json` module, which provides methods for parsing JSON strings 
      into Python objects (like dictionaries and lists) and for converting Python objects back into JSON strings.
    code_block:
      language: json
      code: |
        [
          {
            "hostname": "router1",
            "ip_address": "192.168.1.1",
            "device_type": "router"
          },
          {
            "hostname": "switch1",
            "ip_address": "192.168.1.2",
            "device_type": "switch"
          }
        ]
  - title: "YAML"
    content: >
      `YAML` (YAML Ain't Markup Language) is a human-readable data serialization format that is often used for 
      configuration files and data exchange between languages with different data structures. In Python, you 
      can work with YAML data using the `PyYAML` library, which provides methods for parsing YAML strings into 
      Python objects and for converting Python objects back into YAML strings.
    code_block:
      language: yaml
      code: |
        interfaces:
          - name: GigabitEthernet0/1
            status: up
            description: Uplink to ISP
          - name: GigabitEthernet0/2
            status: down
            description: Spare port
  - title: "XML"
    content: >
      `XML` (eXtensible Markup Language) is a markup language that defines a set of rules for encoding documents in a format 
      that is both human-readable and machine-readable. It is commonly used for data exchange between different systems and 
      applications. In Python, you can work with XML data using the built-in `xml.etree.ElementTree` module, which provides 
      methods for parsing XML strings into Python objects and for converting Python objects back into XML strings.
    code_block:
      language: xml
      code: |
        <devices>
          <device>
            <hostname>router1</hostname>
            <ip_address>192.168.1.1</ip_address>
            <device_type>router</device_type>
          </device>
          <device>
            <hostname>switch1</hostname>
            <ip_address>192.168.1.2</ip_address>
            <device_type>switch</device_type>
          </device>
        </devices>
  - title: "CSV"
    content: >
      `CSV` (Comma-Separated Values) is a simple file format used to store tabular data, such as a spreadsheet or database. Each 
      line in a CSV file represents a row of data, and each value in the row is separated by a comma. In Python, you can work with 
      CSV data using the built-in `csv` module, which provides methods for reading and writing CSV files.
    code_block:
      language: csv
      code: |
        hostname,ip_address,device_type
        router1,192.168.1.1,router
        switch1,192.168.1.2,switch

overview: >
  This lab warms up core Python skills for network automation. You’ll separate logic into
  modules (class + parsing helpers), read structured data (JSON, YAML, XML, CSV), and emit
  clear log lines that double as your grading criteria.

before_you_begin: >
  Open the dev container, confirm Python runs, and ensure you can list files under `data/`
  and write to `logs/`.

resources:
  - { title: "Python logging", url: "https://docs.python.org/3/library/logging.html" }
  - { title: "json", url: "https://docs.python.org/3/library/json.html" }
  - { title: "yaml (PyYAML)", url: "https://pyyaml.org/wiki/PyYAMLDocumentation" }
  - { title: "xml.etree.ElementTree", url: "https://docs.python.org/3/library/xml.etree.elementtree.html" }
  - { title: "csv", url: "https://docs.python.org/3/library/csv.html" }

faq:
  - q: "Where should logs go?"
    a: "Write to `logs/lab.log` and include the required markers listed in the README."
  - q: "Why split code into modules?"
    a: "It keeps functions/classes reusable and testing simpler; the main program stays small."

submission_checklist:
  - "`logs/lab.log` exists and includes LAB1_START/LAB1_END and all required markers."
  - "Parser functions handle JSON, YAML, XML, and CSV without crashing."
  - "At least one `DEVICE_SUMMARY` log line appears."
  - "`INTERFACE_MSG`, `DEVICE_MSG`, and `VLAN_MSG` appear at least once each."
  - "All code lives under `src/` and runs from `main.py`."

steps:
  - title: "Clone the Repository"
    goal: "Get the starter locally."
    actions: |
      Clone your Classroom repo and `cd` into it. Review the provided `data/` files and `src/` layout.
    done_when: |
      - You are in the repo folder and see `data/`, `logs/`, and `src/`.
      - You created `logs/` if it didn’t exist.
    log_marker: "LAB1_START"

  - title: "Open Dev Container"
    goal: "Use the standardized toolchain."
    actions: |
      Reopen in container and wait for the first-time install to finish. Verify `python --version`.
    done_when: |
      - Python prints a version (3.11+).
      - You append `[STEP 2] Dev Container Started` to the log.
    log_marker: "[STEP 2] Dev Container Started"

  - title: "Implement `NetworkDevice` class"
    goal: "Model a network device and log a summary."
    actions: |
      In `src/network_device.py`, implement/confirm the `NetworkDevice` class with `summarize()`
      that logs `DEVICE_SUMMARY: <hostname> (<type>) - <ip>`.
    done_when: |
      - A call to `summarize()` returns a string and writes a `DEVICE_SUMMARY` line to the log.
    log_marker: "DEVICE_SUMMARY"

  - title: "Implement parser helpers"
    goal: "Parse each structured data file safely."
    actions: |
      In `src/parser_utils.py`, implement `parse_json()`, `parse_yaml()`, `parse_xml()`, and `parse_csv()`.
      On success, log `PARSE_*_SUCCESS`; on failure, log `PARSE_*_ERROR` and return an empty list.
    done_when: |
      - Running the script produces `PARSE_JSON_SUCCESS`, `PARSE_YAML_SUCCESS`,
        `PARSE_XML_SUCCESS`, and `PARSE_CSV_SUCCESS` in the log.
    log_marker: "PARSE_JSON_SUCCESS, PARSE_YAML_SUCCESS, PARSE_XML_SUCCESS, PARSE_CSV_SUCCESS"

  - title: "Wire up `main.py`"
    goal: "Load data, build objects, and summarize."
    actions: |
      In `src/main.py`, configure logging to `logs/lab.log` once.
      Load `data/devices.json` (and other files) using your parser helpers.
      For each device, build a `NetworkDevice` and call `summarize()`.
    done_when: |
      - Device summaries are printed and logged.
    log_marker: "DEVICE_SUMMARY"

  - title: "Print + log required messages"
    goal: "Echo required lines for grading."
    actions: |
      Iterate your parsed data to produce:
        - `Interface { interface.name } is { interface.status }`
        - `Device { device.hostname } is a { device.location } { device.role }`
        - `VLAN { vlan.id } is the { vlan.name }`
      After each print, log:
        - `logging.info(f"INTERFACE_MSG: {msg}")`
        - `logging.info(f"DEVICE_MSG: {msg}")`
        - `logging.info(f"VLAN_MSG: {msg}")`
    done_when: |
      - Terminal shows the three message types at least once.
      - Log file includes `INTERFACE_MSG`, `DEVICE_MSG`, and `VLAN_MSG`.
    log_marker: "INTERFACE_MSG, DEVICE_MSG, VLAN_MSG"

  - title: "Refactor & tidy"
    goal: "Keep modules clean and imports explicit."
    actions: |
      Ensure only `main.py` runs the workflow; helpers stay importable and short.
    done_when: |
      - Code style is clean; modules are < ~100 lines each.
    log_marker: "MODULES_OK"

  - title: "Commit, push, and open PR"
    goal: "Submit work for grading."
    actions: |
      Commit your changes; push; open a PR targeting `main`.
    done_when: |
      - PR is open and CI passes.
    log_marker: "LAB1_END"








